# RUN: toyc-lab %s -emit=mlir-affine 2>&1 | FileCheck %s

def main() {
  var a<2, 3> = [[1, 2, 3], [4, 5, 6]];
  var b<2, 3> = [1, 2, 3, 4, 5, 6];
  var c = a-b;
  print(c);
}


# CHECK-LABEL: func @main()
# CHECK-DAG:     [[VAL_0:%.*]] = arith.constant 1.000000e+00 : f64
# CHECK-DAG:     [[VAL_1:%.*]] = arith.constant 2.000000e+00 : f64
# CHECK-DAG:     [[VAL_2:%.*]] = arith.constant 3.000000e+00 : f64
# CHECK-DAG:     [[VAL_3:%.*]] = arith.constant 4.000000e+00 : f64
# CHECK-DAG:     [[VAL_4:%.*]] = arith.constant 5.000000e+00 : f64
# CHECK-DAG:     [[VAL_5:%.*]] = arith.constant 6.000000e+00 : f64
# CHECK:         [[VAL_6:%.*]] = memref.alloc() : memref<2x3xf64>
# CHECK:         [[VAL_7:%.*]] = memref.alloc() : memref<2x3xf64>
# CHECK:         affine.store [[VAL_0]], [[VAL_7]][0, 0] : memref<2x3xf64>
# CHECK:         affine.store [[VAL_1]], [[VAL_7]][0, 1] : memref<2x3xf64>
# CHECK:         affine.store [[VAL_2]], [[VAL_7]][0, 2] : memref<2x3xf64>
# CHECK:         affine.store [[VAL_3]], [[VAL_7]][1, 0] : memref<2x3xf64>
# CHECK:         affine.store [[VAL_4]], [[VAL_7]][1, 1] : memref<2x3xf64>
# CHECK:         affine.store [[VAL_5]], [[VAL_7]][1, 2] : memref<2x3xf64>
# CHECK:         affine.for [[VAL_8:%.*]] = 0 to 2 {
# CHECK:           affine.for [[VAL_9:%.*]] = 0 to 3 {
# CHECK:             [[VAL_10:%.*]] = affine.load [[VAL_7]]{{\[}}[[VAL_8]], [[VAL_9]]] : memref<2x3xf64>
# CHECK:             [[VAL_11:%.*]] = arith.subf [[VAL_10]], [[VAL_10]] : f64
# CHECK:             affine.store [[VAL_11]], [[VAL_6]]{{\[}}[[VAL_8]], [[VAL_9]]] : memref<2x3xf64>
# CHECK:         toy.print [[VAL_6]] : memref<2x3xf64>
# CHECK:         memref.dealloc [[VAL_7]] : memref<2x3xf64>
# CHECK:         memref.dealloc [[VAL_6]] : memref<2x3xf64>
